{"version":3,"sources":["dmAppointment.ts","index.tsx"],"names":["say","text","send","_context","type","value","askAndListen","entry","on","RECOGNISED","target","cond","context","grammar","recResult","utterance","actions","assign","answer","TIMEOUT","title","day","time","dmMachine","initial","states","idle","CLICK","init","TTS_READY","welcome","prompt","ENDSPEECH","ask","nomatch","split","slice","join","person","question","a","l","length","replace","findName","XIs","getFeature","invoke","id","src","event","kbRequest","onDone","feature","data","AbstractText","onError","success","definiens","keep","fail","MeetX","proceed","always","goodBye","createMeeting","setDay","askComplete","setTime","confirmationTime","confirmationComplete","confirmationMeeting","fetch","Request","then","json","cancel","REGION","inspect","url","iframe","machine","Machine","dm","asrtts","audioCtx","_ctx","window","AudioContext","webkitAudioContext","navigator","mediaDevices","getUserMedia","audio","stream","createMediaStreamSource","getToken","_evt","getAuthorizationToken","azureAuthorizationToken","ponyfillTTS","_event","callback","_onReceive","ponyfill","createSpeechSynthesisPonyfill","audioContext","credentials","region","authorizationToken","speechSynthesis","SpeechSynthesisUtterance","tts","ttsUtterance","addEventListener","voices","getVoices","voiceRe","RegExp","process","voice","find","v","test","name","console","error","TTS_ERROR","LISTEN","SPEAK","ttsAgenda","recognising","exit","ASRRESULT","SELECT","noinput","delay","tdmPassivity","STARTSPEECH","inprogress","match","pause","speaking","recLogResult","log","logIntent","nluData","intent","ReactiveButton","props","promptText","state","tdmVisualOutputInfo","el","attribute","promptImage","circleClass","matches","className","alt","style","FigureButton","caption","alternative","imageSrc","App","useMachine","devTools","changeColour","asEffect","document","body","background","recStart","asr","start","recStop","abort","ttsStart","content","REACT_APP_TTS_LEXICON","debug","onend","speak","ttsStop","ponyfillASR","SpeechRecognition","createSpeechRecognitionPonyfill","lang","continuous","interimResults","onresult","result","results","isFinal","transcript","confidence","current","figureButtons","tdmExpectedAlternatives","filter","o","visual_information","map","i","onClick","semantic_expression","method","headers","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.60d6daaa.chunk.js","sourcesContent":["import { Context } from \"microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognizerConfig\";\nimport { MachineConfig, send, Action, assign } from \"xstate\";\nimport { respond } from \"xstate/lib/actions\";\n\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction findName(question: string) {    // MB created function\n    let a = question.split(\" \"); // MB. array\n    let l = a.length;\n    let f = a.slice(2, l);       // MB. final words\n    let j = f.join(\" \");         // MB. note multi-token names, e.g. [\"who\", \"is\", \"Elvis\", \"Aaron\", \"Presley\"]\n    let n = j.replace(\"?\", \"\");  // MB. name\n    return n\n}\n\nfunction findWhoIs(question: string) {  // MB created function\n    let a = question.split(\" \"); // MB. array\n    let b = a.slice(0, 2);       // MB. begining \"Who is\"\n    let j = b.join(\" \");\n    return j\n}\n\nfunction keepItShort(definiens: string, keep: number) {    // MB created function\n    let a = definiens.split(\". \");    // MB. array\n    let r = a.slice(0, keep);         // MB. reduce\n    let j = r.join(\". \");\n    return j\n}\n\nfunction askAndListen(): MachineConfig<SDSContext, any, SDSEvent> {     // MB created function\n    return {\n        entry: send('LISTEN'),\n        on: {\n            RECOGNISED: [\n            {\n                target: 'proceed',\n                cond: (context) => \"answer\" in (grammar[context.recResult[0].utterance] || {}), \n                actions: assign({ answer: (context) => grammar[context.recResult[0].utterance].answer! })\n            },\n            { target: 'nomatch' }\n            ],\n            TIMEOUT: 'prompt'\n        }\n    }\n}\n\nconst grammar: { [index: string]: { title?: string, day?: string, time?: string, answer?: string} } = {\n    \"Lecture.\": { title: \"Dialogue systems lecture\" },\n    \"Lunch.\": { title: \"Lunch at the canteen\" },\n    \"on Friday.\": { day: \"Friday\" },\n    \"Monday\": { day: \"Monday\" },           // MB. some new grammar ...   VVVVVVV\n    \"Tuesday\": { day: \"Tuesday\" },\n    \"Wednesday\": { day: \"Wednesday\" },\n    \"Thursday\": { day: \"Thursday\" },\n    \"Friday\": { day: \"Friday\" }, \n    \"Saturday\": { day: \"Saturday\" },\n    \"Sunday\": { day: \"Sunday\" },         \n    \"Monday.\": { day: \"Monday\" },           \n    \"Tuesday.\": { day: \"Tuesday\" },\n    \"Wednesday.\": { day: \"Wednesday\" },\n    \"Thursday.\": { day: \"Thursday\" },\n    \"Friday.\": { day: \"Friday\" }, \n    \"Saturday.\": { day: \"Saturday\" },\n    \"Sunday.\": { day: \"Sunday\" },         \n    \"At ten.\": { time: \"10:00\" },\n    \"At 10\": { time: \"10:00\" },\n    \"At 10.\": { time: \"10:00\" },           \n    \"At 10:00 o'clock.\": { time: \"10:00\" }, \n    \"At 10 am.\": { time: \"10:00\" },\n    // ============  Answers  ==============\n    \"Yes.\": { answer: \"Yes.\" },\n    \"Yeah.\": { answer: \"Yes.\" },\n    \"Yep.\": { answer: \"Yes.\" },\n    \"No.\": { answer: \"No.\" },\n    \"Nope.\": { answer: \"No.\" },\n}\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    states: { // MB. `states` start here \n        idle: { on: { CLICK: 'init' } },\n        init: { on: { TTS_READY: 'welcome', CLICK: 'welcome' } },\n        welcome: {      // MB.\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"Hi Username\" /*`Hi ${username}!`*/), // MB. variable??\n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: { entry: send('LISTEN') },\n                nomatch: {\n                    entry: say(\"Sorry, I don't know what that is. I can only book meetings and tell you about people.\"),\n                    on: { ENDSPEECH: 'ask' }\n                }\n            },\n            on: {\n                RECOGNISED: [\n                    {\n                        target: 'createMeeting',\n                        cond: (context) => context.recResult[0].utterance === \"Create a meeting.\"\n                    },\n                    {\n                        target: 'XIs',\n                        cond: (context) => findWhoIs(context.recResult[0].utterance) === \"Who is\",\n                        actions: [\n                            assign({ person: (context) => findName(context.recResult[0].utterance)! }),\n                            //(context) => console.log(context.recResult[0]), \n                            //(context) => console.log(findName(context.recResult[0].utterance)),\n                            //(context) => console.log(`Person from Context: ${context.person}`),\n                        ]\n                    },\n                    { target: '.nomatch' }\n                ],\n                TIMEOUT: '.prompt'\n            },\n\n        },\n\n        XIs: {                 // MB.\n            initial: 'getFeature', \n            states: {\n                getFeature: {\n                    invoke: {\n                        id: 'getFeature',\n                        src: (context, event) => kbRequest(context.person),\n                        onDone: {\n                            target: 'success',\n                            actions: [\n                                assign({ feature: (context, event) => event.data.AbstractText }), // MB. note data structure\n                                assign({ title: (context) => `meeting with ${context.person}`! })\n                                //(context, event) => console.log(context, event)\n                            ]\n                        },\n                        onError: { target: 'fail' }\n                    },\n                },\n                success: {\n                    entry: send((context: SDSContext) => ({\n                        type: \"SPEAK\", value: keepItShort(context.feature, 2)\n                    })),\n                    on: { ENDSPEECH: '#root.dm.MeetX' }\n                },\n                fail: {\n                    entry: say(\"Sorry. I do not know this person.\"),\n                    on: { ENDSPEECH: '#root.dm.init'}\n                }\n            },\n        }, \n\n        MeetX: {\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: send((context: SDSContext) => ({\n                        type: \"SPEAK\", value: `Do you want to meet ${context.person}?.` })),\n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: {...askAndListen()},\n                nomatch: {\n                    entry: send((context: SDSContext) => ({\n                        type: \"SPEAK\", value: `Sorry, I don't understand. Do you want to meet ${context.person}?.` })),\n                    on: { ENDSPEECH: 'ask' }                    \n                },\n                proceed: {\n                    always: [\n                        {\n                            target: '#root.dm.setDay', \n                            cond: (context) => context.answer === \"Yes.\"\n                            //cond: (context) => context.recResult[0].utterance === \"Yes.\"\n                        },\n                        {\n                            target: '#root.dm.goodBye',\n                            cond: (context) => context.answer === \"No.\"\n                            //cond: (context) => context.recResult[0].utterance === \"No.\"\n                        },\n                    ]\n                }\n            }\n        }, \n\n        goodBye: {               // MB. \n            initial: 'prompt',\n            states: {prompt: {\n                entry: say(\"OK. Good bye.\"), \n                on: { ENDSPEECH: '#root.dm.init'}}}\n        },           \n\n        createMeeting: { // MB.     [START] --> [TITLE?]\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"Let's create a meeting. What is it about?\"),\n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: { entry: send('LISTEN') },\n                nomatch: {\n                    entry: say(\"Sorry, I don't know what that is. Tell me something I know.\"),\n                    on: { ENDSPEECH: 'ask' }\n                }\n            },\n            on: {\n                RECOGNISED: [\n                    {\n                        target: 'setDay', // MB\n                        cond: (context) => \"title\" in (grammar[context.recResult[0].utterance] || {}),\n                        actions: assign({ title: (context) => grammar[context.recResult[0].utterance].title! })\n                    },\n                    { target: '.nomatch' }\n                ],\n                TIMEOUT: '.prompt'  \n            },\n        }, \n\n        setDay: {   // MB.          ... --> [DAY?] --> \n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"On which day is it?.\"),\n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: { entry: send('LISTEN') },\n                nomatch: {\n                    entry: say(\"Sorry, I don't understand. Please, tell me again. On which day is your meeting?.\"),\n                    on: { ENDSPEECH: 'ask' }\n                }\n            },\n            on: {\n                RECOGNISED: [\n                    {\n                        target: 'askComplete', \n                        cond: (context) => \"day\" in (grammar[context.recResult[0].utterance] || {}), // MB changed key\n                        actions: assign({ day: (context) => grammar[context.recResult[0].utterance].day! })\n                    },\n                    { target: '.nomatch' }\n                ],\n                TIMEOUT: '.prompt'\n            }\n        },         \n\n        askComplete: { // MB.           ... --> [COMPLETE?] --> \n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"Will it take the whole day?.\"),\n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: {...askAndListen()},\n                nomatch: {\n                    entry: say(\"Sorry, I don't understand. Please, tell me again. Will the meeting take the whole day?.\"),\n                    on: { ENDSPEECH: 'ask' }\n                },\n                proceed: {\n                    always: [\n                        {                        \n                            target: '#root.dm.confirmationComplete', \n                            cond: (context) => context.answer === \"Yes.\"\n                            //cond: (context) => context.recResult[0].utterance === \"Yes.\"\n                        },\n                        {\n                            target: '#root.dm.setTime',\n                            cond: (context) => context.answer === \"No.\"\n                            //cond: (context) => context.recResult[0].utterance === \"No.\"\n                        }\n                    ]\n                }\n            }\n        },           \n\n        setTime: { // MB.           ... --> [TIME?] --> \n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"What time is your meeting?.\"),\n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: { entry: send('LISTEN') },\n                nomatch: {\n                    entry: say(\"Sorry, I don't understand. Please, tell me again. What time is your meeting?.\"),\n                    on: { ENDSPEECH: 'ask' }\n                }\n            },\n            on: {\n                RECOGNISED: [\n                    {\n                        target: 'confirmationTime',\n                        cond: (context) => \"time\" in (grammar[context.recResult[0].utterance] || {}), // MB changed key\n                        actions: assign({ time: (context) => grammar[context.recResult[0].utterance].time! }) \n                    },\n                    { target: '.nomatch' }\n                ],\n                TIMEOUT: '.prompt'\n            },\n          \n        },\n\n        confirmationTime: { // MB.     [CONFIRM TIME]\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: 'SPEAK',\n                        value: `Do you want me to create a meeting titled ${context.title} on ${context.day} at ${context.time}?.`})),                    \n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: {...askAndListen()},\n                nomatch: {\n                    entry: send((context) => ({\n                        type: 'SPEAK',\n                        value: `Sorry, I don't understand. Please, tell me again. Do you want me to create a meeting titled ${context.title} on ${context.day} at ${context.time}?.`})),                    \n                    on: { ENDSPEECH: 'ask' }\n                },\n                proceed: {\n                    always: [\n                        {\n                            target: '#root.dm.confirmationMeeting',\n                            cond: (context) => context.answer === \"Yes.\",\n                            //cond: (context) => context.recResult[0].utterance === \"Yes.\", // MB. new condition\n                        },\n                        {\n                            target: '#root.dm.welcome', \n                            cond: (context) => context.answer === \"Yes.\",\n                            //cond: (context) => context.recResult[0].utterance === \"No.\" // MB. new cond\n                        },\n    \n                    ]\n                }\n            },\n        },\n\n        confirmationComplete: { // MB.        [CONFIRM COMPLETE]\n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: 'SPEAK',\n                        value: `Do you want me to create a meeting titled ${context.title} on ${context.day} for the whole day?.`})),                    \n                    on: { ENDSPEECH: 'ask' }\n                },\n                ask: {...askAndListen()},\n                nomatch: {\n                    entry: send((context) => ({\n                        type: 'SPEAK',\n                        value: `Sorry, I don't understand. Please, tell me again. Do you want me to create a meeting titled ${context.title} on ${context.day} for the whole day?.`})),                    \n                    on: { ENDSPEECH: 'ask' }\n                },\n                proceed: {\n                    always: [\n                        {\n                            target: '#root.dm.confirmationMeeting',\n                            cond: (context) => context.answer === \"Yes.\",\n                            //cond: (context) => context.recResult[0].utterance === \"Yes.\" // MB. new cond\n                        },\n                        {\n                            target: '#root.dm.welcome', // MB\n                            cond: (context) => context.answer === \"Yes.\",\n                            //cond: (context) => context.recResult[0].utterance === \"No.\" // MB. new cond                        \n                        },\n    \n                    ]\n                }\n            },            \n        },\n\n        confirmationMeeting: { // MB. \n            initial: 'prompt',\n            states: {\n                prompt: {\n                    entry: say(\"Your meeting has been created.\"),\n                },\n            },\n            on: { ENDSPEECH: 'init' }            \n        }, \n    } // MB. `states` end here \n})\n\nconst kbRequest = (text: string) =>\n    fetch(new Request(`https://cors.eu.org/https://api.duckduckgo.com/?q=${text}&format=json&skip_disambig=1`)).then(data => data.json())\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, actions, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { dmMachine } from \"./dmAppointment\"; // MB changed this \n// import { dmMachine } from \"./dmColourChanger\"; // MB comment out\n\nimport createSpeechRecognitionPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/SpeechToText'\nimport createSpeechSynthesisPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/TextToSpeech';\n\n\nconst { send, cancel } = actions\n\nconst TOKEN_ENDPOINT = 'https://northeurope.api.cognitive.microsoft.com/sts/v1.0/issuetoken';\nconst REGION = 'northeurope';\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\n\nconst defaultPassivity = 10\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dmMachine\n        },\n\n        asrtts: {\n            initial: 'init',\n            states: {\n                init: {\n                    on: {\n                        CLICK: {\n                            target: 'getToken',\n                            actions: [\n                                assign({\n                                    audioCtx: (_ctx) =>\n                                        new ((window as any).AudioContext || (window as any).webkitAudioContext)()\n                                }),\n                                (context) =>\n                                    navigator.mediaDevices.getUserMedia({ audio: true })\n                                        .then(function(stream) { context.audioCtx.createMediaStreamSource(stream) })\n                            ]\n                        }\n                    }\n                },\n                getToken: {\n                    invoke: {\n                        id: \"getAuthorizationToken\",\n                        src: (_ctx, _evt) => getAuthorizationToken(),\n                        onDone: {\n                            actions: [\n                                assign((_context, event) => { return { azureAuthorizationToken: event.data } }),\n                                'ponyfillASR'],\n                            target: 'ponyfillTTS'\n                        },\n                        onError: {\n                            target: 'fail'\n                        }\n                    }\n                },\n                ponyfillTTS: {\n                    invoke: {\n                        id: 'ponyTTS',\n                        src: (context, _event) => (callback, _onReceive) => {\n                            const ponyfill = createSpeechSynthesisPonyfill({\n                                audioContext: context.audioCtx,\n                                credentials: {\n                                    region: REGION,\n                                    authorizationToken: context.azureAuthorizationToken,\n                                }\n                            });\n                            const { speechSynthesis, SpeechSynthesisUtterance } = ponyfill;\n                            context.tts = speechSynthesis\n                            context.ttsUtterance = SpeechSynthesisUtterance\n                            context.tts.addEventListener('voiceschanged', () => {\n                                context.tts.cancel()\n                                const voices = context.tts.getVoices();\n                                let voiceRe = RegExp(\"en-US\", 'u')\n                                if (process.env.REACT_APP_TTS_VOICE) {\n                                    voiceRe = RegExp(process.env.REACT_APP_TTS_VOICE, 'u')\n                                }\n                                const voice = voices.find((v: any) => voiceRe.test(v.name))!\n                                if (voice) {\n                                    context.voice = voice\n                                    callback('TTS_READY')\n                                } else {\n                                    console.error(`TTS_ERROR: Could not get voice for regexp ${voiceRe}`)\n                                    callback('TTS_ERROR')\n                                }\n                            })\n                        }\n                    },\n                    on: {\n                        TTS_READY: 'idle',\n                        TTS_ERROR: 'fail'\n                    }\n                },\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    },\n                },\n                recognising: {\n                    initial: 'noinput',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => {\n                                    return {\n                                        recResult: event.value\n                                    }\n                                })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle',\n                        SELECT: 'idle',\n                        CLICK: '.pause'\n                    },\n                    states: {\n                        noinput: {\n                            entry: [\n                                'recStart',\n                                send(\n                                    { type: 'TIMEOUT' },\n                                    { delay: (context) => (1000 * (context.tdmPassivity || defaultPassivity)), id: 'timeout' }\n                                )],\n                            on: {\n                                TIMEOUT: '#root.asrtts.idle',\n                                STARTSPEECH: 'inprogress'\n                            },\n                            exit: cancel('timeout')\n                        },\n                        inprogress: {\n                        },\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                        pause: {\n                            entry: 'recStop',\n                            on: { CLICK: 'noinput' }\n                        }\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                        SELECT: 'idle',\n                        CLICK: { target: 'idle', actions: send('ENDSPEECH') }\n                    },\n                    exit: 'ttsStop',\n                },\n                fail: {}\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('U>', context.recResult[0][\"utterance\"], context.recResult[0][\"confidence\"]);\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n    alternative: any;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    var promptText = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"name\") || {}).value;\n    var promptImage = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"image\") || {}).value;\n    var circleClass = \"circle\"\n    switch (true) {\n        case props.state.matches({ asrtts: 'fail' }) || props.state.matches({ dm: 'fail' }):\n            break;\n        case props.state.matches({ asrtts: { recognising: 'pause' } }):\n            promptText = \"Click to continue\"\n            break;\n        case props.state.matches({ asrtts: 'recognising' }):\n            circleClass = \"circle-recognising\"\n            promptText = promptText || 'Listening...'\n            break;\n        case props.state.matches({ asrtts: 'speaking' }):\n            circleClass = \"circle-speaking\"\n            promptText = promptText || 'Speaking...'\n            break;\n        case props.state.matches({ dm: 'idle' }):\n            promptText = \"Click to start!\"\n            circleClass = \"circle-click\"\n            break;\n        case props.state.matches({ dm: 'init' }):\n            promptText = \"Click to start!\"\n            circleClass = \"circle-click\"\n            break;\n        default:\n            promptText = promptText || '\\u00A0'\n    }\n    return (\n        <div className=\"control\">\n            <figure className=\"prompt\">\n                {promptImage &&\n                    <img src={promptImage}\n                        alt={promptText} />}\n            </figure>\n            <div className=\"status\">\n                <button type=\"button\" className={circleClass}\n                    style={{}} {...props}>\n                </button>\n                <div className=\"status-text\">\n                    {promptText}\n                </div>\n            </div>\n        </div>);\n}\n\nconst FigureButton = (props: Props): JSX.Element => {\n    const caption = props.alternative.find((el: any) => el.attribute === \"name\").value\n    const imageSrc = (props.alternative.find((el: any) => el.attribute === \"image\") || {}).value\n    return (\n        <figure className=\"flex\" {...props}>\n            {imageSrc &&\n                <img src={imageSrc} alt={caption} />}\n            <figcaption>{caption}</figcaption>\n        </figure>\n    )\n}\n\nfunction App() {\n    const [current, send] = useMachine(machine, {\n        devTools: true,\n        actions: {\n\n            changeColour: asEffect((context) => {\n                document.body.style.background = context.recResult[0].utterance;\n                /* console.log('Ready to receive a voice input.'); */\n            }),\n\n            recStart: asEffect((context) => {\n                context.asr.start()\n                /* console.log('Ready to receive a voice input.'); */\n            }),\n            recStop: asEffect((context) => {\n                context.asr.abort()\n                /* console.log('Recognition stopped.'); */\n            }),\n            ttsStart: asEffect((context) => {\n                let content = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xmlns:mstts=\"http://www.w3.org/2001/mstts\" xml:lang=\"en-US\"><voice name=\"${context.voice.name}\">`\n                content = content + (process.env.REACT_APP_TTS_LEXICON ? `<lexicon uri=\"${process.env.REACT_APP_TTS_LEXICON}\"/>` : \"\")\n                content = content + `${context.ttsAgenda}</voice></speak>`\n                console.debug(content)\n                const utterance = new context.ttsUtterance(content);\n                console.log(\"S>\", context.ttsAgenda)\n                utterance.voice = context.voice\n                utterance.onend = () => send('ENDSPEECH')\n                context.tts.speak(utterance)\n            }),\n            ttsStop: asEffect((context) => {\n                /* console.log('TTS STOP...'); */\n                context.tts.cancel()\n            }),\n            ponyfillASR: asEffect((context, _event) => {\n                const\n                    { SpeechRecognition }\n                        = createSpeechRecognitionPonyfill({\n                            audioContext: context.audioCtx,\n                            credentials: {\n                                region: REGION,\n                                authorizationToken: context.azureAuthorizationToken,\n                            }\n                        });\n                context.asr = new SpeechRecognition()\n                context.asr.lang = process.env.REACT_APP_ASR_LANGUAGE || 'en-US'\n                context.asr.continuous = true\n                context.asr.interimResults = true\n                context.asr.onresult = function(event: any) {\n                    var result = event.results[0]\n                    if (result.isFinal) {\n                        send({\n                            type: \"ASRRESULT\", value:\n                                [{\n                                    \"utterance\": result[0].transcript,\n                                    \"confidence\": result[0].confidence\n                                }]\n                        })\n                    } else {\n                        send({ type: \"STARTSPEECH\" });\n                    }\n                }\n\n            })\n        }\n    });\n    const figureButtons = (current.context.tdmExpectedAlternatives || []).filter((o: any) => o.visual_information)\n        .map(\n            (o: any, i: any) => (\n                <FigureButton state={current}\n                    alternative={o.visual_information}\n                    key={i}\n                    onClick={() => send({ type: 'SELECT', value: o.semantic_expression })} />\n            )\n        )\n\n    switch (true) {\n        default:\n            return (\n                <div className=\"App\">\n                    <ReactiveButton state={current} alternative={{}} onClick={() => send('CLICK')} />\n                    <div className=\"select-wrapper\">\n                        <div className=\"select\">\n                            {figureButtons}\n                        </div>\n                    </div>\n                </div>\n            )\n    }\n\n};\n\nconst getAuthorizationToken = () => (\n    fetch(new Request(TOKEN_ENDPOINT, {\n        method: 'POST',\n        headers: {\n            'Ocp-Apim-Subscription-Key': process.env.REACT_APP_SUBSCRIPTION_KEY!\n        },\n    })).then(data => data.text()))\n\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n"],"sourceRoot":""}