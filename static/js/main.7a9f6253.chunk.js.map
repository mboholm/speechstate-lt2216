{"version":3,"sources":["dmAppointmentPlus.ts","index.tsx"],"names":["say","text","send","_context","type","value","sayAnything","functionForWhatToSay","binaryInfoRequest","whatToSay","onYes","onNo","initial","entry","assign","correction","context","timeout","states","prompt","on","ENDSPEECH","ask","RECOGNISED","target","actions","whatissaid","recResult","utterance","clevel","confidence","TIMEOUT","cond","cMgnt","console","log","always","cReq","confirmation","grammar","answer","cReqProcessing","mainTaskProcessing","proceed","gate","firstConfusion","backToConversation","secondConfusion","thirdConfusion","openInfoRequest","whereToTransition","contextFiller","whatToAssign","correctionExpression","whereToGo","internal","title","day","time","robot","dmMachine","idle","CLICK","init","TTS_READY","help","conversation","user","hist","history","welcome","split","slice","join","person","question","a","l","length","replace","findName","XIs","getFeature","invoke","id","src","event","kbRequest","onDone","feature","data","AbstractText","onError","success","definiens","keep","fail","robotAction","askIntent","intent","goFindIntent","getIntent","fetch","Request","method","body","then","json","prediction","name","askNewIntent","MeetX","goodBye","createMeeting","setDay","askComplete","setTime","confirmationTime","confirmationComplete","confirmationMeeting","cancel","REGION","inspect","url","iframe","machine","Machine","dm","asrtts","audioCtx","_ctx","window","AudioContext","webkitAudioContext","navigator","mediaDevices","getUserMedia","audio","stream","createMediaStreamSource","getToken","_evt","getAuthorizationToken","azureAuthorizationToken","ponyfillTTS","_event","callback","_onReceive","ponyfill","createSpeechSynthesisPonyfill","audioContext","credentials","region","authorizationToken","speechSynthesis","SpeechSynthesisUtterance","tts","ttsUtterance","addEventListener","voices","getVoices","voiceRe","RegExp","process","voice","find","v","test","error","TTS_ERROR","LISTEN","SPEAK","ttsAgenda","recognising","exit","ASRRESULT","SELECT","RECSTOP","noinput","delay","tdmPassivity","STARTSPEECH","inprogress","match","pause","speaking","recLogResult","logIntent","nluData","ReactiveButton","props","promptText","state","tdmVisualOutputInfo","el","attribute","promptImage","circleClass","matches","className","alt","style","FigureButton","caption","alternative","imageSrc","App","useMachine","devTools","changeColour","asEffect","document","background","recStart","asr","start","recStop","abort","ttsStart","content","REACT_APP_TTS_LEXICON","debug","onend","speak","ttsStop","ponyfillASR","SpeechRecognition","createSpeechRecognitionPonyfill","lang","continuous","interimResults","onresult","result","results","isFinal","transcript","current","figureButtons","tdmExpectedAlternatives","filter","o","visual_information","map","i","onClick","semantic_expression","headers","rootElement","getElementById","ReactDOM"],"mappings":"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","file":"static/js/main.7a9f6253.chunk.js","sourcesContent":["import { TIMEOUT } from \"dns\";\nimport { Context } from \"microsoft-cognitiveservices-speech-sdk/distrib/lib/src/common.speech/RecognizerConfig\";\nimport { MachineConfig, send, Action, assign, State } from \"xstate\";\nimport { respond } from \"xstate/lib/actions\";\n\n//const rasaurl = 'https://rasa-nlu-api-00.herokuapp.com/model/parse'\nconst rasaurl = 'https://dialsys2022.herokuapp.com/model/parse'\nconst nluRequest = (text: string) =>\n  fetch(new Request(rasaurl, {\n      method: 'POST',\n      body: `{\"text\": \"${text}\"}`\n  }))\n      .then(data => data.json());\n\nfunction removeUnderscore (text: string) {\n    return text.replace(\"_\", \" \")\n}\n\nfunction say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nfunction sayAnything( functionForWhatToSay: any ) { // MB. This is basically send() under an another name\n    return send(functionForWhatToSay)\n}\n\nfunction findName(question: string) {    // MB created function\n    let a = question.split(\" \"); // MB. array\n    let l = a.length;\n    let f = a.slice(2, l);       // MB. final words\n    let j = f.join(\" \");         // MB. note multi-token names, e.g. [\"who\", \"is\", \"Elvis\", \"Aaron\", \"Presley\"]\n    let n = j.replace(\"?\", \"\");  // MB. name\n    return n\n}\n\nfunction findWhoIs(question: string) {  // MB created function\n    let a = question.split(\" \"); // MB. array\n    let b = a.slice(0, 2);       // MB. begining \"Who is\"\n    let j = b.join(\" \");\n    return j\n}\n\nfunction keepItShort(definiens: string, keep: number) {    // MB created function\n    let a = definiens.split(\". \");    // MB. array\n    let r = a.slice(0, keep);         // MB. reduce\n    let j = r.join(\". \");\n    return j\n}\n\nfunction binaryInfoRequest(whatToSay: any, onYes: string, onNo: string ):MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        initial: \"prompt\",\n        entry: [\n            assign( {correction: (context) => context.correction = 0} ), \n            assign( {timeout: (context) => context.timeout = 0} )\n        ],\n        states: {\n            prompt: {\n                entry: sayAnything(whatToSay),                    \n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {\n                entry: send('LISTEN'),\n                on: {\n                    RECOGNISED: {\n                        target: 'cMgnt',\n                        actions: [\n                            assign({ whatissaid: (context) => context.recResult[0].utterance }),\n                            assign({ clevel: (context) => context.recResult[0].confidence })\n                        ]\n                    },\n                    TIMEOUT: [\n                        {\n                            target: 'prompt',\n                            cond: (context: SDSContext) => context.timeout < 3,\n                            actions: assign({timeout: (context) => context.timeout + 1 })\n                        },\n                        {\n                            target: '#root.dm.init'\n                        }\n                    ]\n                }\n            },\n            cMgnt: {\n                entry: (context: SDSContext) => console.log(context.clevel),\n                always: [\n                    {\n                        target: 'cReq',\n                        cond: (context) => context.clevel < 0.5 // MB. threshold for confidence\n                    },\n                    {\n                        target: 'mainTaskProcessing'\n                    },\n                ]\n            },\n            cReq: {\n                initial: \"prompt\",\n                states: {\n                    prompt: {\n                        entry: sayAnything((context: SDSContext) => ({type: \"SPEAK\", value: `Did you say ${context.whatissaid}.`})),\n                        on: { ENDSPEECH: 'confirmation' }\n                    },\n                    confirmation: {entry: send('LISTEN')},\n                },\n                on: {\n                    RECOGNISED: [\n                    {\n                        target: 'cReqProcessing',\n                        cond: (context) => \"answer\" in (grammar[context.recResult[0].utterance] || {}), \n                        actions: assign({ answer: (context) => grammar[context.recResult[0].utterance].answer! })\n                    },\n                    {\n                        target: '#root.dm.help',\n                        cond: (context: SDSContext) => context.recResult[0].utterance === \"Help.\"\n                    },\n                    { // MB. Simplified... no altered reprompts or conditions\n                        target: '.prompt'\n                    }\n                    ],\n                    TIMEOUT: [\n                        { // MB. Simplified...\n                            target: '.prompt'\n                        },        \n                    ]\n                }\n            },\n            cReqProcessing: {\n                always: [\n                    {\n                        target: 'mainTaskProcessing',\n                        cond: (context) => context.answer === \"Yes.\"\n                    },\n                    {\n                        target: 'prompt',\n                        cond: (context) => context.answer === \"No.\"\n                    },\n                ]\n            },\n            mainTaskProcessing: {\n                always: [\n                    {\n                        target: 'proceed',\n                        cond: (context) => \"answer\" in (grammar[context.whatissaid] || {}), \n                        actions: assign({ answer: (context) => grammar[context.whatissaid].answer! })\n                    },\n                    {\n                        target: '#root.dm.help',\n                        cond: (context: SDSContext) => context.whatissaid === \"Help.\"\n                    },\n                    { \n                        target: 'gate',\n                    }\n                ]\n            },\n            proceed: {\n                always: [\n                    {\n                        target: onYes,\n                        cond: (context: SDSContext) => context.answer === \"Yes.\",\n                    },\n                    {\n                        target: onNo,\n                        cond: (context: SDSContext) => context.answer === \"No.\",\n                    },\n                ]\n            },\n            gate: { // MB. nomatchHandling\n                entry: (context:SDSContext) => console.log(`Correction count: ${context.correction}`),\n                always: [\n                    {\n                        target: 'firstConfusion',\n                        cond: (context: SDSContext) => context.correction === 0\n                    },\n                    {\n                        target: 'secondConfusion',\n                        cond: (context: SDSContext) => context.correction === 1\n                    },\n                    {\n                        target: 'thirdConfusion',\n                        cond: (context: SDSContext) => context.correction === 2\n                    }\n                ]\n            },\n            firstConfusion: {...backToConversation(\"I do not understand. Please tell me again.\", \"prompt\")},\n            secondConfusion: {...backToConversation(\"I still do not understand. Please tell me again.\", \"prompt\")},\n            thirdConfusion: {...backToConversation(\"This is not going anywhere. Good bye.\", '#root.dm.init')},\n        },\n    }\n}\n\nfunction openInfoRequest(whatToSay: any , whereToTransition: string, contextFiller: string, whatToAssign: any): MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        initial: \"prompt\",\n        entry: [\n            assign( {correction: (context) => context.correction = 0} ), \n            assign( {timeout: (context) => context.timeout = 0} )\n        ],\n        states: {\n            prompt: {\n                entry: sayAnything(whatToSay),                    \n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {\n                entry: send('LISTEN'),\n                on: {\n                    RECOGNISED: {\n                        target: 'cMgnt',\n                        actions: [\n                            assign({ whatissaid: (context) => context.recResult[0].utterance }),\n                            assign({ clevel: (context) => context.recResult[0].confidence })\n                        ]\n                    },\n                    TIMEOUT: [\n                        {\n                            target: 'prompt',\n                            cond: (context: SDSContext) => context.timeout < 3,\n                            actions: assign({timeout: (context) => context.timeout + 1 })\n                        },\n                        {\n                            target: '#root.dm.init'\n                        }\n                    ]\n                }\n            },\n            cMgnt: {\n                entry: (context: SDSContext) => console.log(context.clevel),\n                always: [\n                    {\n                        target: 'cReq',\n                        cond: (context) => context.clevel < 0.5\n                    },\n                    {\n                        target: 'mainTaskProcessing'\n                    },\n                ]\n            },\n            cReq: {\n                initial: \"prompt\",\n                states: {\n                    prompt: {\n                        entry: sayAnything((context: SDSContext) => ({type: \"SPEAK\", value: `Did you say ${context.whatissaid}.`})),\n                        on: { ENDSPEECH: 'confirmation' }\n                    },\n                    confirmation: {entry: send('LISTEN')},\n                },\n                on: {\n                    RECOGNISED: [\n                    {\n                        target: 'cReqProcessing',\n                        cond: (context) => \"answer\" in (grammar[context.recResult[0].utterance] || {}), \n                        actions: assign({ answer: (context) => grammar[context.recResult[0].utterance].answer! })\n                    },\n                    {\n                        target: '#root.dm.help',\n                        cond: (context: SDSContext) => context.recResult[0].utterance === \"Help.\"\n                    },\n                    { // MB. Simplified... no altered reprompts or conditions\n                        target: '.prompt'\n                    }\n                    ],\n                    TIMEOUT: [\n                        { // MB. Simplified...\n                            target: '.prompt'\n                        },        \n                    ]\n                }\n            },\n            cReqProcessing: {\n                always: [\n                    {\n                        target: 'mainTaskProcessing',\n                        cond: (context) => context.answer === \"Yes.\"\n                    },\n                    {\n                        target: 'prompt',\n                        cond: (context) => context.answer === \"No.\"\n                    },\n                ]\n            },\n            mainTaskProcessing: {\n                always: [\n                    {\n                        target: whereToTransition,\n                        cond: (context) => contextFiller in (grammar[context.whatissaid] || {}), \n                        actions: assign(whatToAssign)\n                    },\n                    {\n                        target: '#root.dm.help',\n                        cond: (context: SDSContext) => context.whatissaid === \"Help.\"\n                    },\n                    { \n                        target: 'gate',\n                    }\n                ]\n            },\n            gate: {  // MB. nomatchHandling\n                entry: (context:SDSContext) => console.log(`Correction count: ${context.correction}`),\n                always: [\n                    {\n                        target: 'firstConfusion',\n                        cond: (context: SDSContext) => context.correction === 0\n                    },\n                    {\n                        target: 'secondConfusion',\n                        cond: (context: SDSContext) => context.correction === 1\n                    },\n                    {\n                        target: 'thirdConfusion',\n                        cond: (context: SDSContext) => context.correction === 2\n                    }\n                ]\n            },\n            firstConfusion: {...backToConversation(\"I do not understand. Please tell me again.\", \"prompt\")},\n            secondConfusion: {...backToConversation(\"I still do not understand. Please tell me again.\", \"prompt\")},\n            thirdConfusion: {...backToConversation(\"This is not going anywhere. Good bye.\", '#root.dm.init')},\n        },\n    }\n}\n\nfunction backToConversation(correctionExpression: string, whereToGo: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        entry: say(correctionExpression),\n        on: { \n            ENDSPEECH: {\n                target: whereToGo,\n                internal: false,\n                actions: assign({correction: (context) => context.correction + 1 }), // add 1 on every attempt\n            } \n        }\n    }\n}\n\nfunction nomatchHandling() {\n    return {\n        gate: {\n            entry: (context:SDSContext) => console.log(`Correction count: ${context.correction}`),\n            always: [\n                {\n                    target: 'firstConfusion',\n                    cond: (context: SDSContext) => context.correction === 0\n                },\n                {\n                    target: 'secondConfusion',\n                    cond: (context: SDSContext) => context.correction === 1\n                },\n                {\n                    target: 'thirdConfusion',\n                    cond: (context: SDSContext) => context.correction === 2\n                }\n            ]\n        },\n        firstConfusion: {...backToConversation(\"I do not understand. Please tell me again.\", \"prompt\")},\n        secondConfusion: {...backToConversation(\"I still do not understand. Please tell me again.\", \"prompt\")},\n        thirdConfusion: {...backToConversation(\"This is not going anywhere. Good bye.\", '#root.dm.init')}\n    }\n}\n\nfunction setUp(): MachineConfig<SDSContext, any, SDSEvent> {\n    return {\n        initial: \"prompt\",\n        entry: [\n            assign( {correction: (context) => context.correction = 0} ), \n            assign( {timeout: (context) => context.timeout = 0} )\n        ]\n    }\n}\n\nconst grammar: { [index: string]: \n    { \n        title?: string, \n        day?: string, \n        time?: string, \n        answer?: string,\n        robot?: string\n    } \n} = {\n    \"Lecture.\": { title: \"Dialogue systems lecture\" },\n    \"Lunch.\": { title: \"Lunch at the canteen\" },\n    \"on Friday.\": { day: \"Friday\" },\n    \"Monday\": { day: \"Monday\" },           // MB. some new grammar ...   VVVVVVV (Lab2)\n    \"Tuesday\": { day: \"Tuesday\" },\n    \"Wednesday\": { day: \"Wednesday\" },\n    \"Thursday\": { day: \"Thursday\" },\n    \"Friday\": { day: \"Friday\" }, \n    \"Saturday\": { day: \"Saturday\" },\n    \"Sunday\": { day: \"Sunday\" },         \n    \"Monday.\": { day: \"Monday\" },           \n    \"Tuesday.\": { day: \"Tuesday\" },\n    \"Wednesday.\": { day: \"Wednesday\" },\n    \"Thursday.\": { day: \"Thursday\" },\n    \"Friday.\": { day: \"Friday\" }, \n    \"Saturday.\": { day: \"Saturday\" },\n    \"Sunday.\": { day: \"Sunday\" },         \n    \"At ten.\": { time: \"10:00\" },\n    \"At 10\": { time: \"10:00\" },\n    \"At 10.\": { time: \"10:00\" },           \n    \"At 10:00 o'clock.\": { time: \"10:00\" }, \n    \"At 10 am.\": { time: \"10:00\" },\n    // ============  Answers  ==============\n    \"Yes.\": { answer: \"Yes.\" },\n    \"Yeah.\": { answer: \"Yes.\" },\n    \"Yep.\": { answer: \"Yes.\" },\n    \"No.\": { answer: \"No.\" },\n    \"Nope.\": { answer: \"No.\" },\n    // =========== ROBOT STUFF  =============\n    \"Activate robot.\": { robot: \"Active.\" },\n    \"Robot activation.\": { robot: \"Active.\" },\n}\n\nexport const dmMachine: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    states: { // MB. `states` start here \n        idle: { on: { CLICK: 'init' } },\n        init: { on: { TTS_READY: 'conversation', CLICK: 'conversation' } }, //MB. changed: 'welcome' --> 'conversation'\n\n        help: {       //MB lab5\n            entry: say(\"Calm down. I will walk you through this.\"),\n            on: { \n                ENDSPEECH: '#root.dm.conversation.hist' \n            }\n        },\n\n        conversation: {\n            entry: assign( {user: (context) => context.user = \"Max\"} ),\n            initial: \"welcome\",  \n            states: { \n\n                hist:{\n                    type: \"history\",\n                    history: \"shallow\" // MB. shallow by default\n                }, \n\n                welcome: {      \n                    ...setUp(),\n                    states: {\n                        prompt: {\n                            entry: send((context: SDSContext) => ({type: \"SPEAK\", value: `Hi ${context.user}!`})),\n                            on: { ENDSPEECH: 'ask' }\n                        },\n                        ask: { entry: send('LISTEN') },\n                        ...nomatchHandling()\n                    },\n                    on: {\n                        RECOGNISED: [\n                            {\n                                target: '#root.dm.conversation.createMeeting',\n                                cond: (context) => context.recResult[0].utterance === \"Create a meeting.\"\n                            },\n                            {\n                                target: '#root.dm.conversation.XIs',\n                                cond: (context) => findWhoIs(context.recResult[0].utterance) === \"Who is\",\n                                actions: [\n                                    assign({ person: (context) => findName(context.recResult[0].utterance)! }),\n                                ]\n                            },\n                            { \n                                target: 'robotAction',\n                                cond: (context) => \"robot\" in (grammar[context.recResult[0].utterance] || {})\n                            },\n                            { target: '.gate' }\n                        ],\n                        TIMEOUT: [\n                            {\n                                target: '.prompt',\n                                cond: (context: SDSContext) => context.timeout < 3,\n                                actions: assign({timeout: (context) => context.timeout + 1 })\n                            },\n                            {\n                                target: '#root.dm.init'\n                            }\n                        ]\n                    },\n                },\n\n                XIs: {   \n                    initial: 'getFeature', \n                    states: {\n                        getFeature: {\n                            invoke: {\n                                id: 'getFeature',\n                                src: (context, event) => kbRequest(context.person),\n                                onDone: {\n                                    target: 'success',\n                                    actions: [\n                                        assign({ feature: (context, event) => event.data.AbstractText }), // MB. note data structure\n                                        assign({ title: (context) => `meeting with ${context.person}`! })\n                                    ]\n                                },\n                                onError: { target: 'fail' }\n                            },\n                        },\n                        success: {\n                            entry: send((context: SDSContext) => ({\n                                type: \"SPEAK\", value: keepItShort(context.feature, 1)\n                            })),\n                            on: { ENDSPEECH: '#root.dm.conversation.MeetX' }\n                        },\n                        fail: {\n                            entry: say(\"Sorry. I do not know this person.\"),\n                            on: { ENDSPEECH: '#root.dm.init'}\n                        }\n                    },\n                }, \n\n                robotAction: { //MB. implemented without out-of-grammar intents and below-confidence-level-confirmation\n                    initial: 'askIntent',\n                    states: {\n                        askIntent: {\n                            initial: 'prompt',\n                            states: {\n                                prompt: {\n                                    entry: say(\"What do you want me to do?\"), \n                                    on: { ENDSPEECH: 'ask' }\n                                },\n                                ask: { entry: send('LISTEN') },\n                            },\n                            on: {\n                                RECOGNISED: \n                                {\n                                    target: 'goFindIntent',\n                                    actions: assign( {intent: (context) => context.recResult[0].utterance } )\n                                },\n                                TIMEOUT: '.prompt'\n                            }\n                        },\n                        goFindIntent: {\n                            \n                            initial: 'getIntent', \n                            states: {\n                                getIntent: {\n                                    invoke: {\n                                        id: 'getIntent',\n                                        src: (context, event) => nluRequest(context.intent),\n                                        onDone: {\n                                            target: '#root.dm.conversation.robotAction.goFindIntent.success',\n                                            actions: [\n                                                //(context, event) => console.log(context, event),\n                                                assign({ prediction: (context, event) => event.data.intent.name }), // MB. note data structure\n                                            ]\n                                        },\n                                        onError: { target: '#root.dm.conversation.robotAction.goFindIntent.fail' }\n                                    },\n                                },\n                                success: {\n                                    entry: send((context: SDSContext) => ({\n                                        type: \"SPEAK\", value: `OK. I will ${removeUnderscore(context.prediction)}.`\n                                    })),\n                                    on: { ENDSPEECH: '#root.dm.conversation.robotAction.askNewIntent' }\n                                },\n                                fail: {\n                                    entry: say(\"Sorry. Something went wrong.\"),\n                                    on: { ENDSPEECH: '#root.dm.init'}\n                                }\n                            },\n                        \n                        },\n                        askNewIntent: {\n                            ...binaryInfoRequest(\n                                (context: SDSContext) => ({type: \"SPEAK\", value: 'Do you want me to do anything else?.'}),\n                                '#root.dm.conversation.robotAction.askIntent',\n                                '#root.dm.conversation.goodBye'\n                            )\n                        }\n                    },\n                },\n\n                MeetX: {\n                    ...binaryInfoRequest(\n                        (context: SDSContext) => ({type: \"SPEAK\", value: `Do you want to meet ${context.person}?.`}),\n                        '#root.dm.conversation.setDay',\n                        '#root.dm.conversation.goodBye'\n                    )\n                }, \n\n                goodBye: {   \n                    initial: 'prompt',\n                    states: {prompt: {\n                        entry: say(\"OK. Good bye.\"), \n                        on: { ENDSPEECH: '#root.dm.init'}}}\n                },           \n\n                createMeeting: { \n                    ...openInfoRequest(\n                        (context:SDSContext) => ({type: \"SPEAK\", value: \"Let's create a meeting. What is it about?\"}),\n                        '#root.dm.conversation.setDay',\n                        \"title\",\n                        { title: (context: SDSContext) => grammar[context.recResult[0].utterance].title! }\n                    )\n                }, \n\n                setDay: {    \n                    ...openInfoRequest(\n                        (context:SDSContext)=>({type:\"SPEAK\", value:\"On which day is it?.\"}),\n                        '#root.dm.conversation.askComplete',\n                        \"day\",\n                        { day: (context: SDSContext) => grammar[context.recResult[0].utterance].day! }\n                    )\n                },         \n\n                askComplete: {  \n                    ...binaryInfoRequest(\n                        (context: SDSContext) => ({type:\"SPEAK\", value: \"Will it take the whole day?.\"}),\n                        '#root.dm.conversation.confirmationComplete',\n                        '#root.dm.conversation.setTime'\n                    )\n                },           \n\n                setTime: {  \n                    ...openInfoRequest(\n                        (context: SDSContext) => ({type: \"SPEAK\", value: \"What time is your meeting?.\"}),\n                        '#root.dm.conversation.confirmationTime',\n                        \"time\",\n                        { time: (context: SDSContext) => grammar[context.recResult[0].utterance].time! }\n                    )\n                },\n\n                confirmationTime: { \n                    ...binaryInfoRequest(\n                        (context: SDSContext)=>({type: \"SPEAK\", value: `Do you want me to create a meeting titled ${context.title} on ${context.day} at ${context.time}?.`}),\n                        '#root.dm.conversation.confirmationMeeting',\n                        '#root.dm.conversation.welcome'\n                        )\n                },\n\n                confirmationComplete: { \n                    ...binaryInfoRequest(\n                        (context:SDSContext)=>({type: \"SPEAK\", value: `Do you want me to create a meeting titled ${context.title} on ${context.day} for the whole day?.`}),\n                        '#root.dm.conversation.confirmationMeeting',\n                        '#root.dm.conversation.welcome'\n                    )         \n                },\n\n                confirmationMeeting: {  \n                    initial: 'prompt',\n                    states: {\n                        prompt: {\n                            entry: say(\"Your meeting has been created.\"),\n                        },\n                    },\n                    on: { ENDSPEECH: '#root.dm.init' }            \n                }, \n            }\n        }\n    } // MB. `states` end here \n})\n\nconst kbRequest = (text: string) =>\n    fetch(new Request(`https://cors.eu.org/https://api.duckduckgo.com/?q=${text}&format=json&skip_disambig=1`)).then(data => data.json())\n","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { Machine, assign, actions, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { inspect } from \"@xstate/inspect\";\nimport { dmMachine } from \"./dmAppointmentPlus\"; // MB. for lab 5\n//import { dmMachine } from \"./dmAppointment\"; // MB changed this \n//import { dmMachine } from \"./dmColourChanger\"; // MB comment out\n\nimport createSpeechRecognitionPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/SpeechToText'\nimport createSpeechSynthesisPonyfill from 'web-speech-cognitive-services/lib/SpeechServices/TextToSpeech';\n\n\nconst { send, cancel } = actions\n\nconst TOKEN_ENDPOINT = 'https://northeurope.api.cognitive.microsoft.com/sts/v1.0/issuetoken';\nconst REGION = 'northeurope';\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\n\nconst defaultPassivity = 3\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        dm: {\n            ...dmMachine\n        },\n\n        asrtts: {\n            initial: 'init',\n            states: {\n                init: {\n                    on: {\n                        CLICK: {\n                            target: 'getToken',\n                            actions: [\n                                assign({\n                                    audioCtx: (_ctx) =>\n                                        new ((window as any).AudioContext || (window as any).webkitAudioContext)()\n                                }),\n                                (context) =>\n                                    navigator.mediaDevices.getUserMedia({ audio: true })\n                                        .then(function(stream) { context.audioCtx.createMediaStreamSource(stream) })\n                            ]\n                        }\n                    }\n                },\n                getToken: {\n                    invoke: {\n                        id: \"getAuthorizationToken\",\n                        src: (_ctx, _evt) => getAuthorizationToken(),\n                        onDone: {\n                            actions: [\n                                assign((_context, event) => { return { azureAuthorizationToken: event.data } }),\n                                'ponyfillASR'],\n                            target: 'ponyfillTTS'\n                        },\n                        onError: {\n                            target: 'fail'\n                        }\n                    }\n                },\n                ponyfillTTS: {\n                    invoke: {\n                        id: 'ponyTTS',\n                        src: (context, _event) => (callback, _onReceive) => {\n                            const ponyfill = createSpeechSynthesisPonyfill({\n                                audioContext: context.audioCtx,\n                                credentials: {\n                                    region: REGION,\n                                    authorizationToken: context.azureAuthorizationToken,\n                                }\n                            });\n                            const { speechSynthesis, SpeechSynthesisUtterance } = ponyfill;\n                            context.tts = speechSynthesis\n                            context.ttsUtterance = SpeechSynthesisUtterance\n                            context.tts.addEventListener('voiceschanged', () => {\n                                context.tts.cancel()\n                                const voices = context.tts.getVoices();\n                                let voiceRe = RegExp(\"en-US\", 'u')\n                                if (process.env.REACT_APP_TTS_VOICE) {\n                                    voiceRe = RegExp(process.env.REACT_APP_TTS_VOICE, 'u')\n                                }\n                                const voice = voices.find((v: any) => voiceRe.test(v.name))!\n                                if (voice) {\n                                    context.voice = voice\n                                    callback('TTS_READY')\n                                } else {\n                                    console.error(`TTS_ERROR: Could not get voice for regexp ${voiceRe}`)\n                                    callback('TTS_ERROR')\n                                }\n                            })\n                        }\n                    },\n                    on: {\n                        TTS_READY: 'idle',\n                        TTS_ERROR: 'fail'\n                    }\n                },\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    },\n                },\n                recognising: {\n                    initial: 'noinput',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => {\n                                    return {\n                                        recResult: event.value\n                                    }\n                                })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle',\n                        SELECT: 'idle',\n                        CLICK: '.pause',\n                        RECSTOP: 'idle'\n                    },\n                    states: {\n                        noinput: {\n                            entry: [\n                                'recStart',\n                                send(\n                                    { type: 'TIMEOUT' },\n                                    { delay: (context) => (1000 * (context.tdmPassivity || defaultPassivity)), id: 'timeout' }\n                                )],\n                            on: {\n                                TIMEOUT: '#root.asrtts.idle',\n                                STARTSPEECH: 'inprogress'\n                            },\n                            exit: cancel('timeout')\n                        },\n                        inprogress: {\n                        },\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                        pause: {\n                            entry: 'recStop',\n                            on: { CLICK: 'noinput' }\n                        }\n                    }\n                },\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                        SELECT: 'idle',\n                        CLICK: { target: 'idle', actions: send('ENDSPEECH') }\n                    },\n                    exit: 'ttsStop',\n                },\n                fail: {}\n            }\n        }\n    },\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('U>', context.recResult[0][\"utterance\"], context.recResult[0][\"confidence\"]);\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        },\n    });\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n    alternative: any;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    var promptText = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"name\") || {}).value;\n    var promptImage = ((props.state.context.tdmVisualOutputInfo || [{}])\n        .find((el: any) => el.attribute === \"image\") || {}).value;\n    var circleClass = \"circle\"\n    switch (true) {\n        case props.state.matches({ asrtts: 'fail' }) || props.state.matches({ dm: 'fail' }):\n            break;\n        case props.state.matches({ asrtts: { recognising: 'pause' } }):\n            promptText = \"Click to continue\"\n            break;\n        case props.state.matches({ asrtts: 'recognising' }):\n            circleClass = \"circle-recognising\"\n            promptText = promptText || 'Listening...'\n            break;\n        case props.state.matches({ asrtts: 'speaking' }):\n            circleClass = \"circle-speaking\"\n            promptText = promptText || 'Speaking...'\n            break;\n        case props.state.matches({ dm: 'idle' }):\n            promptText = \"Click to start!\"\n            circleClass = \"circle-click\"\n            break;\n        case props.state.matches({ dm: 'init' }):\n            promptText = \"Click to start!\"\n            circleClass = \"circle-click\"\n            break;\n        default:\n            promptText = promptText || '\\u00A0'\n    }\n    return (\n        <div className=\"control\">\n            <figure className=\"prompt\">\n                {promptImage &&\n                    <img src={promptImage}\n                        alt={promptText} />}\n            </figure>\n            <div className=\"status\">\n                <button type=\"button\" className={circleClass}\n                    style={{}} {...props}>\n                </button>\n                <div className=\"status-text\">\n                    {promptText}\n                </div>\n            </div>\n        </div>);\n}\n\nconst FigureButton = (props: Props): JSX.Element => {\n    const caption = props.alternative.find((el: any) => el.attribute === \"name\").value\n    const imageSrc = (props.alternative.find((el: any) => el.attribute === \"image\") || {}).value\n    return (\n        <figure className=\"flex\" {...props}>\n            {imageSrc &&\n                <img src={imageSrc} alt={caption} />}\n            <figcaption>{caption}</figcaption>\n        </figure>\n    )\n}\n\nfunction App() {\n    const [current, send] = useMachine(machine, {\n        devTools: true,\n        actions: {\n\n            changeColour: asEffect((context) => {\n                document.body.style.background = context.recResult[0].utterance;\n                /* console.log('Ready to receive a voice input.'); */\n            }),\n\n            recStart: asEffect((context) => {\n                context.asr.start()\n                /* console.log('Ready to receive a voice input.'); */\n            }),\n            recStop: asEffect((context) => {\n                context.asr.abort()\n                /* console.log('Recognition stopped.'); */\n            }),\n            ttsStart: asEffect((context) => {\n                let content = `<speak version=\"1.0\" xmlns=\"http://www.w3.org/2001/10/synthesis\" xmlns:mstts=\"http://www.w3.org/2001/mstts\" xml:lang=\"en-US\"><voice name=\"${context.voice.name}\">`\n                content = content + (process.env.REACT_APP_TTS_LEXICON ? `<lexicon uri=\"${process.env.REACT_APP_TTS_LEXICON}\"/>` : \"\")\n                content = content + `${context.ttsAgenda}</voice></speak>`\n                console.debug(content)\n                const utterance = new context.ttsUtterance(content);\n                console.log(\"S>\", context.ttsAgenda)\n                utterance.voice = context.voice\n                utterance.onend = () => send('ENDSPEECH')\n                context.tts.speak(utterance)\n            }),\n            ttsStop: asEffect((context) => {\n                /* console.log('TTS STOP...'); */\n                context.tts.cancel()\n            }),\n            ponyfillASR: asEffect((context, _event) => {\n                const\n                    { SpeechRecognition }\n                        = createSpeechRecognitionPonyfill({\n                            audioContext: context.audioCtx,\n                            credentials: {\n                                region: REGION,\n                                authorizationToken: context.azureAuthorizationToken,\n                            }\n                        });\n                context.asr = new SpeechRecognition()\n                context.asr.lang = process.env.REACT_APP_ASR_LANGUAGE || 'en-US'\n                context.asr.continuous = true\n                context.asr.interimResults = true\n                context.asr.onresult = function(event: any) {\n                    var result = event.results[0]\n                    if (result.isFinal) {\n                        send({\n                            type: \"ASRRESULT\", value:\n                                [{\n                                    \"utterance\": result[0].transcript,\n                                    \"confidence\": result[0].confidence\n                                }]\n                        })\n                    } else {\n                        send({ type: \"STARTSPEECH\" });\n                    }\n                }\n\n            })\n        }\n    });\n    const figureButtons = (current.context.tdmExpectedAlternatives || []).filter((o: any) => o.visual_information)\n        .map(\n            (o: any, i: any) => (\n                <FigureButton state={current}\n                    alternative={o.visual_information}\n                    key={i}\n                    onClick={() => send({ type: 'SELECT', value: o.semantic_expression })} />\n            )\n        )\n\n    switch (true) {\n        default:\n            return (\n                <div className=\"App\">\n                    <ReactiveButton state={current} alternative={{}} onClick={() => send('CLICK')} />\n                    <div className=\"select-wrapper\">\n                        <div className=\"select\">\n                            {figureButtons}\n                        </div>\n                    </div>\n                </div>\n            )\n    }\n\n};\n\nconst getAuthorizationToken = () => (\n    fetch(new Request(TOKEN_ENDPOINT, {\n        method: 'POST',\n        headers: {\n            'Ocp-Apim-Subscription-Key': process.env.REACT_APP_SUBSCRIPTION_KEY!\n        },\n    })).then(data => data.text()))\n\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n"],"sourceRoot":""}